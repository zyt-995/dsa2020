
## #48441182提交状态

# 状态: Accepted

### 基本信息:
#:48441182
题目:
P1100
提交人:
靳敏2400012283
内存:
4672kB
时间:
3535ms
语言:
Python3
提交时间:
2025-03-05 00:50:49

### 解题思路
从r到a的最优解，可以分解成从某个r到某个@的最优解的累加，只要每次都走最优解，则整体最优。——那么可以用动态规划。  

dp[][]是二位数组，dp[i][j]表示从r到(i,j)的最短时间    

要求最短，初始状态都是无穷大。直接按照map的大小初始，后续考虑#不能到  
  

边界从r到r时间为0  
  
状态转移：   
在当前位置向四周探索，不是墙壁，就按照@或者x计算时耗
如果四周某个(ni,nj)在dp中的值大于(i,j)移动过来的时长，就更新(ni,nj)，表示找到更好路径。  
  
最后返回dp[an][am]   

queue = deque([(rn, rm)]) 使用 deque 创建一个队列，并将骑士的初始位置 (rn, rm) 放入队列中。这个队列用于广度优先搜索（BFS），存储待探索的位置。

### 踩过的坑  
注意：map的边界限制，i或j等于0或n，需要注意，可以用方向字典判断（这样写简单一点，要不然会超长50+）  
emm，map有功能，所以最好用别的。要不然会乱套