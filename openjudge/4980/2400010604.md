# 状态: [Accepted](http://xzmdsa.openjudge.cn/2025hw6/solution/49151885/)
```
基本信息
#:
49151885
题目:
250604
提交人:
2400010604李凯瑞
内存:
4488kB
时间:
1482ms
语言:
Python3
提交时间:
2025-05-14 11:04:45
```

## 代码说明
这个问题可以使用广度优先搜索（BFS）来解决，因为我们需要找到从骑士到公主的最短路径，同时考虑守卫带来的额外时间。由于杀死守卫需要额外的时间，普通的BFS可能无法直接得到最短时间，因此我们需要使用优先队列（即Dijkstra算法）来处理这种情况，确保总是先处理当前时间最短的状态。

1. 输入处理：读取测试用例的数量，然后逐个处理每个测试用例。

2. 定位起点和终点：在矩阵中找到骑士（'r'）和公主（'a'）的位置。

3. 优先队列BFS：使用优先队列来进行BFS，队列中的元素按照到达该位置的时间排序。这样每次处理时间最小的节点，确保第一次到达公主位置的时间就是最短时间。

4. 访问标记：维护一个二维数组来记录到达每个位置的最短时间，避免重复处理同一位置的不优解。

5. 方向移动：骑士可以上下左右移动，每次移动检查是否遇到守卫（'x'），道路（'@'），或者墙壁（'#'）。墙壁不可通过，道路和守卫可以通过，但遇到守卫需要额外时间。

6. 终止条件：当到达公主位置时，返回当前时间。如果队列为空且未到达公主位置，则返回"Impossible"。