# 状态: [Accepted](http://xzmdsa.openjudge.cn/2025test2review/solution/48795440/)
```
基本信息
#:
48795440
题目:
25T22
提交人:
2400010604李凯瑞
内存:
3916kB
时间:
42ms
语言:
Python3
提交时间:
2025-04-02 10:13:20
```

## 解题思路
这个问题是动态规划问题。我们需要找到在数字串中插入 K 个乘号，使得分割后的 K+1 个数字的乘积最大。

### 动态规划定义
1. 定义 dp[i][j] 表示在前 i 个数字中插入 j 个乘号时能够获得的最大乘积。

    i 的范围：1 到 N。

    j 的范围：0 到 K（因为最多插入 K 个乘号）。

2. 初始条件
    dp[i][0]：在前 i 个数字中插入 0 个乘号，即整个前 i 个数字作为一个整体。因此，dp[i][0] 就是数字串的前 i 位构成的数字。

### 状态转移方程
    对于 dp[i][j]，我们需要考虑在前 i 个数字中插入 j 个乘号。这可以通过以下方式得到：

    最后一个乘号可以插入在第 m 个数字之后（其中 m 从 j 到 i-1），这样：

    前 m 个数字中插入 j-1 个乘号，得到 dp[m][j-1]。

    剩下的 i - m 个数字作为一个整体，即 num[m+1..i]。

    因此，dp[i][j] = max(dp[m][j-1] * num[m+1..i])，其中 m 从 j 到 i-1。

### 计算顺序
    我们需要按顺序计算 dp[i][j]：

    首先初始化 dp[i][0] 为前 i 个数字组成的数字。

    对于每个 j 从 1 到 K：

    对于每个 i 从 j+1 到 N（因为至少需要 j+1 个数字才能插入 j 个乘号）：

    对于 m 从 j 到 i-1：

    计算 dp[m][j-1] * num[m+1..i]，并取最大值作为 dp[i][j]。