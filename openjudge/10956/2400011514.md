# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/48413288/)

```
基本信息
#: 48413288
题目: P1210
提交人: 谢冰2400011514(xb谢神)
内存: 6596kB
时间: 731ms
语言: Python3
提交时间: 2025-03-02 14:38:58
```

**使用 Dijkstra 算法**

- 由于移动代价 `1` 和 `2`（杀蛇）不同，普通 BFS 可能导致错误的路径计算。
- 使用 **优先队列 `heapq`**，保证总是扩展当前最短时间的路径。

**正确处理蛇的状态**

- `snake_mask` 需要记录哪些蛇已被杀，以避免重复计算杀蛇时间。

**钥匙获取逻辑**

- 必须按照 **从 `1` 到 `M`** 的顺序依次获取钥匙，不能跳过。
  
**复杂度分析**

- 时间复杂度：O(N^2 * 2^M)
    - `N^2` 是宫殿的格子数
    - `2^M` 是钥匙状态的可能性
    - 由于 `heapq` 优化，每个状态扩展操作是 `O(log (N^2 * 2^M))`
- 空间复杂度：O(N^2 * 2^M)
    - 主要存储 `memo[x][y][key_count]`，每个 `(x, y)` 状态最多 `M+1` 种钥匙状态