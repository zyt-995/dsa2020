# 状态: [Accepted](http://xzmdsa.openjudge.cn/2025hw3/solution/48620984/)
```
基本信息
#: 48620984
题目: 250303
提交人: 2400012262+周知勤(Tianyi)
内存: 3692kB
时间: 29ms
语言: Python3
提交时间: 2025-03-18 20:39:38
```

# 1. 问题分析

本题描述了一套防空导弹拦截系统，具备如下缺陷：  
- 第一发拦截导弹（炮弹）可以到达任意高度；  
- 后续每一发拦截导弹的高度不能超过**上一发**拦截导弹的高度（可以相等）。

给定敌方导弹依次来袭的高度序列，问该系统能够**拦截**的最大数量是多少。

从算法视角来看，这相当于在给定序列中寻找长度最大的**非升序**（或称“单调不增”）子序列。用更通俗的话来说，每次能拦截一个高度，而下一次拦截时需要选择一个高度小于或等于前一次拦截高度的导弹。最后统计可拦截的导弹总数。

# 2. 对解题方法的说明

1. **转换为动态规划求解**  
   - 可以用一个 `dp[i]` 表示“以第 `i` 枚导弹作为末尾时，能拦截的导弹最大数量”。
   - 对于每个位置 `i`，我们在它之前的所有位置 `j`（`0 <= j < i`）中，若 `data[i] <= data[j]`，说明第 `i` 号导弹可以接在第 `j` 号导弹之后拦截（因为拦截高度不升），于是有
     
     $$
       \text{dp}[i] = \max(\text{dp}[i], \text{dp}[j] + 1) .
     $$
     
   - 初始化 `dp` 数组为 `1`，表示默认每个导弹都能单独拦截一次。
   - 最后结果取 `max(dp)` 即可。

2. **时间复杂度**  
   - 该方法是典型的二重循环 `O(n^2)` 动态规划。根据题目数据要求，当 `N<=15` 时，不会超时。

# 3.解题感想
本题十分抽象，开始做题时可能不会想到本题的考察要求（反正我开始没想到它的要求，后面WA几次后才想到拦截导弹时需要和敌军达到相同高度，故后面的导弹以一定会越来越低）。但当我们将它抽象为寻找最大长度的**非递增子序列**之后，难度大大降低。仅仅是简单的**单串线性动态规划**问题，而且本题`N<=15`规模较小，这进一步降低了本题的难度。

故总的来说，本题难度不大，但关键在于将这个问题抽象出来。
