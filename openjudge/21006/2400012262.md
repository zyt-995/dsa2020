# 状态: [Accepted](http://xzmdsa.openjudge.cn/2025hw2/solution/48548826/)
```
基本信息
#: 48548826
题目: 250205
提交人: 2400012262+周知勤(Tianyi)
内存: 3584kB
时间: 30ms
语言: Python3
提交时间: 2025-03-13 15:55:23
```

# 问题分析

我们有 \(M\) 个完全相同的苹果，准备放进 \(N\) 个完全相同的盘子里。题目允许盘子为空，且因为盘子是“相同的”，在分配结果中只要出现相同数量分配方式就视为同一种。例如：
- \(M=7, N=3\)，一种分配方式可以是 
\[5, 1, 1\]
将它调换成 \[1, 5, 1\] 或 \[1, 1, 5\] 在本题中都**不再**是新的分法，因为盘子没有区分。

题目要求计算：在不区分盘子先后顺序的前提下，把 \(M\) 个苹果分到 \(N\) 个盘子里共有多少种不同的分法。

这是一个经典的**整数划分**问题的变形。常见的思路有两种：

1. **动态规划/记忆化搜索**  
2. **动态规划**  

在本题中，使用了典型的**带记忆化**的**递归**方法。

# 2. 对解题方法的说明

设函数 `find(a, b)` 表示“将 `a` 个苹果放入 `b` 个相同盘子中的方法数”。可以用以下递推关系求解：

1. **边界条件**  
   - 当 `b == 1` 时，无论有多少苹果，只能放在**同一个盘子**或那个盘子什么都不放——整体看都只有 1 种放法；  
   - 当 `a == 0` 时，没有苹果可放，也只有 1 种方式（所有盘子均为空）；  
   - 当 `b > a` 时，盘子数比苹果数还多，多出来的盘子相当于“空的”，于是只需要关心最多 `a` 个盘子，因此可以改写为 `find(a, a)`。

2. **递推关系**  
   - `find(a, b-1)`: 不使用第 `b` 个盘子（相当于该盘子为空），所以就是把 `a` 个苹果放入 `b-1` 个盘子的所有方法数；  
   - `find(a-b, b)`: 给每个盘子最少放 1 个苹果（这样才能保证所有盘子都有苹果），先从 `a` 中拿出 `b` 个苹果均分给 `b` 个盘子（每个 1 个），还剩 `a-b` 个苹果再放回到 `b` 个盘子中。  
   - 二者相加得到总数：  
     \[
     \text{find}(a, b) = \text{find}(a,\,b-1) \;+\; \text{find}(a-b,\,b)
     \]

有了上述关系后，我们在代码中通过**记忆化字典 `memo`** 来缓存已经计算过的 `(a, b)` 值，避免重复计算。

# 解题感想
1. 最开始做这道题时，直接开始递归，没有使用记忆化搜索，但也能ac本题（），但为了优化本题的时间复杂度，于是采用的记忆化搜索来减少递归的次数。构建了一个字典`dict`（作为缓存`cache`），储存`(a,b)`即将a个苹果放在b个盘子里的情况。当后面还遇到相同的放置情况时直接返回，避免深度递归。
2. 当`b > a`的时候，可以选择直接返回`find(a,a)`因为多余的盘子必定为空，这样也可以减少递归的次数。

