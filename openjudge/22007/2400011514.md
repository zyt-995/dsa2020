# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/49249297/)

```
基本信息
#: 49249297
题目: P0230
提交人: 谢冰2400011514(xb谢神)
内存: 3916kB
时间: 23ms
语言: Python3
提交时间: 2025-05-24 12:57:55
```

要解决N皇后问题，我们需要在一个N×N的棋盘上放置N个皇后，使得它们彼此之间不能互相攻击。这意味着任何两个皇后不能在同一行、同一列或同一对角线上。我们可以使用回溯法来系统地探索所有可能的放置方式，并记录所有有效的解决方案。

### 方法思路
1. **回溯法**：我们从棋盘的第一行开始，尝试在每一列放置皇后。对于每一个放置的位置，检查是否与之前放置的皇后冲突。如果没有冲突，就递归地在下一行继续放置皇后；如果有冲突，则尝试当前行的下一个列位置。
2. **冲突检查**：每次放置新皇后时，需要检查当前列以及两个对角线是否已经有皇后存在。具体来说，对于位置(row, col)，我们需要检查：
   - 列冲突：该列col是否在之前行的皇后位置中。
   - 对角线冲突：当前行和列之差(row - col)是否等于之前某一行和列之差（主对角线冲突），或者当前行和列之和(row + col)是否等于之前某一行和列之和（副对角线冲突）。
3. **记录解**：每当所有N个皇后都被成功放置在棋盘上时，记录当前的位置配置作为一个解。

### 代码解释
1. **输入处理**：读取整数N，表示棋盘的大小和皇后的数量。
2. **回溯函数backtrack**：该函数递归地尝试在每一行放置皇后：
   - **参数说明**：`row`表示当前处理的行，`cols`记录已占用的列，`diag1`和`diag2`分别记录主对角线和副对角线，`path`保存当前路径（即每行皇后所在的列）。
   - **终止条件**：当`row`等于N时，表示所有行都已成功放置皇后，将当前路径添加到解决方案列表中。
   - **列遍历**：对于当前行的每一列，检查放置皇后是否与之前的皇后冲突。若无冲突，则递归处理下一行，并在回溯时撤销当前选择，继续尝试其他列。
3. **输出处理**：如果没有解决方案，输出"NO ANSWER"；否则，按要求的顺序输出所有解决方案，每个方案为一行，列号由空格分隔。

这种方法有效地探索了所有可能的皇后放置方式，并通过回溯剪枝避免了不必要的检查，确保在合理的时间内找到所有解。