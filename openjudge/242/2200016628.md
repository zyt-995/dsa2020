### 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/49260234)
```
#:49260234
题目:P0810
提交人:B-2200016628-谢艺
内存:3796kB
时间:25ms
语言:Python3
提交时间:2025-05-25 12:41:53
```
## 思路

- **前序遍历：** 根 → 子树1 → 子树2 → … → 子树k
    
- **后序遍历：** 子树1 → 子树2 → … → 子树k → 根
### **子树划分：前序中找每个子树，结合后序定位子树结束点**

对于 `preord[1:]`，我们想办法将它划分成若干段，每一段对应一个子树，则：

- 从 `preord[1]` 开始，这就是第一个子树的根。
    
- 在 `postord` 中找这个节点在哪个位置，设为 `i`，则 `postord[postleft:i+1]` 是这棵子树的后序遍历，且这颗子树的长度为 `i - postleft + 1`
    
- 根据长度和前序中根节点位置，这也确定了子树的前序区间。下一个子树的根在前序中的位置也就知道了，是当前这个子树前序区间的下一个。
    

重复上述过程，依次识别出所有子树。
### **递归处理每棵子树**

- 对每一棵识别出来的子树，递归地调用 `possible(...)`，统计该子树的结构数。
    
- 把所有子树结构数 **相乘**，得到在给定子树顺序下的结构总数。

### **考虑孩子顺序可变**

m 叉树的孩子是**有顺序的**，因此：  
对于某个节点有 `cnt` 个子树，其不同排列方式有 `C(m, cnt)` 种