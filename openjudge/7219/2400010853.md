# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/48331578/)

```
基本信息
#:48331578
题目:P0930
提交人:2400010853 林泽锋(林泽锋)
内存:7620kB
时间:281ms
语言:Python3
提交时间:2025-02-22 15:35:21
```

# 问题分析：

输入：这题采用的是多组输入，在python里面可以使用import sys实现

第一个问题:

我们采用引进dp[][]二维list，希望dp1[i][j]记录下把j分为i个数的分拆数，接下来我们来寻找递推。

当j<i:没有这样的分拆，当j=i有且仅有一个分拆

对于j>i时，考虑分拆中有没有1.

如果有1，把1去掉即得到“把j-1分拆成i-1个数的分拆方式”，为dp[i-1][j-1]

如果没有1，即分拆出的每一个数均至少是2，把每一个分拆出的数都减去1，得到“把j-i分拆成i个数的分拆方式”，为dp1[i][j-i]，得到

    dp1[i][j]=dp1[i-1][j-1]+dp1[i][j-i](j>i)

第二个问题：

我们采用二维dp的思想，但为了节省空间，这里对一维列表进行迭代即可，第i次迭代完得到的dp[j]代表着：把j拆成若干个不同且最大数不超过i的分拆数（如何用二维已在代码注释说明）

对一般的j>i，考虑分拆数中最大是否含i

如果不含i，则最大数不超过i-1，这就是上一次(第i-1次)迭代中的dp[j]

如果含i：则去掉i后由于互不相同，即为就是上一次(第i-1次)迭代中的dp[j-i]，即

    dp2[j]+=dp2[j-i]

但这里有坑！：上一行必须要求dp[j]比dp[j-i]更先更新，防止若dp[j-i]已经包含了含i的分拆方法数。所以循环的时候要从大到小循环，即采用

    for i in range(1,n+1):
            for j in range(n,i-1,-1):

最后循环后输出dp[n]即可



第三个问题与第二个问题较为类似，对于奇数的处理利用

    for i in range(1,n+1,2):
            for j in range(i,n+1):

步长为2的计算即可

# 对程序结构的分析：

由于输入为多组，就可以引入函数，然后循环读入，不断调用函数即可

# 踩过的坑：

dp不断更新数组时，注意谁先发生变化，防止多算/少算。例如如果要求要求dp[j]比dp[j-i]更先更新，那就要按需循环
