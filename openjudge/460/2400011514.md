# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/48971454/)

```
基本信息
#: 48971454
题目: P0910
提交人: 谢冰2400011514(xb谢神)
内存: 3896kB
时间: 41ms
语言: Python3
提交时间: 2025-04-21 08:14:35
```

要解决这个问题，我们需要找到两个字符串的最长公共子序列（LCS）的长度。最长公共子序列是指在两个字符串中以相同顺序出现但不一定连续的最长子序列。动态规划是解决这个问题的经典方法。

### 方法思路
1. **动态规划定义状态**：我们使用一个二维数组 `dp[i][j]` 来表示字符串 `X` 的前 `i` 个字符和字符串 `Y` 的前 `j` 个字符的最长公共子序列的长度。
2. **状态转移方程**：
   - 如果 `X[i-1] == Y[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`。
   - 否则，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
3. **初始化**：`dp` 数组的大小为 `(len(X)+1) x (len(Y)+1)`，初始时所有元素为0。
4. **填充dp数组**：通过双重循环遍历两个字符串的每个字符，根据状态转移方程填充dp数组。
5. **返回结果**：`dp[len(X)][len(Y)]` 即为所求的最长公共子序列的长度。

### 代码解释
1. **函数定义**：`longest_common_subsequence` 函数计算两个字符串 `X` 和 `Y` 的最长公共子序列长度。
   - **初始化dp数组**：创建一个 `(m+1) x (n+1)` 的二维列表 `dp`，初始值为0，`m` 和 `n` 分别是两个字符串的长度。
   - **填充dp数组**：通过双重循环遍历每个字符，如果当前字符相等，则状态值由左上角的值加1；否则取左边或上边的最大值。
   - **返回结果**：`dp[m][n]` 存储的就是最长公共子序列的长度。
2. **输入处理**：使用 `sys.stdin` 读取输入，按行处理，每行分割成两个字符串后调用 `longest_common_subsequence` 函数并输出结果。

这种方法有效地利用动态规划避免了重复计算，确保了在 O(mn) 的时间和空间复杂度内解决问题，其中 m 和 n 是两个字符串的长度。