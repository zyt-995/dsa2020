## 状态: [Accepted]

~~~
语言:Python3
基本信息#:
48312903
题目:P0510
提交人:2400011491王思杰(24n2400011491)
内存:13144kB
时间:88ms
提交时间:2025-02-19 23:15:20
~~~



### 题目分析与解题思路

由于本题的数据量刻意选择得特别大，题目的最大难点就在于如何通过o(1)复杂度的实现题目要求的min操作——这其实很像greedy的思路。

显然，我们需要一个列表pigs来储存猪堆叠的顺序，方便进行pop操作——对列表来说，这个操作是o(1)复杂度的。但列表的min()操作是o(logN)复杂度的，所以这里肯定没法只通过一个列表解决问题。

注意到（这其实很困难），每新堆上一只猪，如果这只猪比之前的最轻的猪重，那这只猪根本就不会影响min输出的结果，因此，我创建了另一个列表my_pigs来储存最小的猪的堆叠——先判断新的猪是否比之前最轻的猪轻，如果是就加入my_pigs。这样，my_pigs[-1]就是最轻的猪的重量。

在每次pop的时候，我们需要检查最小的猪有没有被pop掉。因此，我们需要将被pop的猪的重量与最轻的重量对比，如果相同则说明最轻的猪被pop掉了。注意，这里有一个问题，可能有复数猪同时具有最轻的重量，只是pop掉其中一只可能不会改变min的输出结果——因此，在先前我们创建my_pigs时，如果新的猪和之前最轻的猪重量相等，也应当储存入my_pigs.



### 我遇到的坑

1、类似greedy的难点：新堆上的猪如果比之前最轻的重，就完全不会影响min的操作结果

2、可能有复数的猪同时具有最轻的重量，所以最轻的猪不能只存一个

3、检查最轻的猪有没有被pop掉

4、我最开始在思考用最小堆heapq，但实际上这道题完全没有必要用这个（当然用这个也能过）。如果采用了最小堆，对最小堆需要做的操作和my_pigs的是差不多的。
