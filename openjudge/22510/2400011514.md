# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/48828238/)

```
基本信息
#: 48828238
题目: P1270
提交人: 谢冰2400011514(xb谢神)
内存: 6344kB
时间: 29ms
语言: Python3
提交时间: 2025-04-06 09:05:21
```

​思路：观察题目描述可知，从皮卡丘所在位置（顶点0）到小智所在位置（顶点1）的简单路径中，每个经过的森林隘口（编号从2开始）只需要支付一次“战斗时间”（击败宝可梦所需的时间），而边上则有跑步的时间。由于正权图中最短路一定为简单路（没有重复顶点），故我们可以将“隘口上的战斗时间”看作是顶点的“进入代价”，并将其并入到入边的权值中。

具体做法是：  
- 对于每条无向边 \( u-v \) 及跑步时间 \( t \) ，构造两个有向边  
  - 从 \( u \) 到 \( v \) 的代价为  
    - 如果 \( v \ge 2 \)（即森林隘口），代价为 \( t + \text{defeat}[v] \)  
    - 如果 \( v \) 是 0 或 1，则代价为 \( t \)  
  - 同理从 \( v \) 到 \( u \) 的代价为 \( t + \text{(if \( u\ge2 \) then defeat[u] else 0)} \)  
- 最终问题转换为：在改权后的有向图中求从 0 到 1 的最短距离。


### 说明

- **图的构造：**  
  对于每条无向边，将其拆成两条有向边。注意对于森林隘口（编号\( \ge 2 \)），在入边时加上相应的击败时间；而对于顶点 0 和 1，不加额外时间。

- **最短路求解：**  
  使用 Dijkstra 算法求解从顶点 0 到顶点 1 的最短路径。由于所有权值均为正数，最短路径必为简单路径，因此这种“加边”方式不会重复计入某个隘口的战斗时间。

- **样例验证：**  
  对样例输入  
  ```
  2 5
  1
  1
  0 2 4
  3 0 1
  2 3 1
  2 1 2
  1 3 5
  ```  
  处理后，算法会计算出最短路径为 0 → 3 → 2 → 1，总时间为 6，与样例输出一致。

这种方法利用了正权图中简单路径的性质，避免了显式记录哪些隘口已经经过，从而简化了问题。