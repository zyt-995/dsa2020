# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/48346083/)

```
基本信息
#: 48346083
题目: P1234
提交人: 谢冰2400011514(xb谢神)
内存: 3948kB
时间: 29ms
语言: Python3
提交时间: 2025-02-24 11:09:50
```

这个问题可以看作是一个最小生成树（Minimum Spanning Tree, MST）的问题。我们需要找到一组边，使得所有节点都连通，并且总花费最小。我们可以使用Kruskal算法或Prim算法来解决这个问题。这里我们选择Kruskal算法，因为它更容易实现。

Kruskal算法的基本思想是：
1. 将所有边按权重从小到大排序。
2. 依次选择边，如果这条边连接的两个节点不在同一个集合中，则将它们合并，并将这条边加入最小生成树中。
3. 重复步骤2，直到所有节点都在同一个集合中。

为了实现Kruskal算法，我们需要使用并查集（Disjoint Set Union, DSU）数据结构来管理节点的集合。

### 代码说明：
1. **DSU类**：实现了并查集数据结构，用于管理节点的集合。`find`方法用于查找节点的根，`union`方法用于合并两个集合。
2. **kruskal函数**：实现了Kruskal算法。首先对边按权重排序，然后依次选择边并尝试合并两个节点所在的集合。如果合并成功，则将这条边加入最小生成树中。
3. **main函数**：读取输入数据，调用`kruskal`函数计算最小生成树，并输出结果。

### 复杂度分析：
- 时间复杂度：O(m log m)，其中m是边的数量。排序边的时间复杂度是O(m log m)，Kruskal算法的时间复杂度是O(m α(n))，其中α(n)是反阿克曼函数，通常很小。
- 空间复杂度：O(n + m)，用于存储边和并查集数据结构。

这个算法能够有效地解决这个问题，并且在给定的输入范围内表现良好。