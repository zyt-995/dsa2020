# 状态:[Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/48345564/)
    基本信息
    #:48345564
    题目:P0550
    提交人:2400010836姚一凡(Zhuiy)
    内存:6804kB
    时间:192ms
    语言:Python3
    提交时间:2025-02-24 00:01:07

# 分析
这道题纯枚举的O(n^2)算法应该是过不了，需要简化。
1) 从左还是右入手：如果想要简化，肯定需要在处理一只牛时，利用上之前处理的牛。那肯定就是从右入手比较合理。
2) 开始尝试：比如处理第i只，我们先一个一个比，考虑i与i+1的高度关系，如果i比i+1矮，那么很简单，它只能看到这一只；如果i比i+1高，枚举简单情况就能发现，它肯定能看到i+1看到的所有牛，这时我们只需要考虑第i+1只后第一个比i+1高的，当他是j吧，去考虑它能不能被i看到。

   此时，j成了新的（i+1），我们再去考虑以上两种情况，如果j比i高，那直接结束，如果j比i矮，我们就去找j看不到的第一支牛，让i和它比，因为此时j能看见的，i一定也能看见！！
3) 有了这个简化思路，就可以尝试实现，需要注意的是，在我们处理i时，对我们有用的牛是：i+1，j（第一个比i+1高的），k（第一个比j高的）......

    不难发现，我们需要维护的这个辅助数列是单增的，而且符合“第一个”这样的要求
# 初级实现
1) 我们从最后一只牛开始处理，它什么也看不到，把他加入辅助数列up，因为倒数第二只牛肯定要和它比
2) 当我们处理第i只牛时，我们先把它和辅助数列里面最后一项比较（很快就能说明这一项一定是第i+1只），然后和倒数第二个，直到比到一个比它高的，或者比完所有up中的牛为止

    这时我们找到第一个比它高的牛（或者都比他矮），记录这两只牛之间的位置差，把差加到answer中即可（这里要求我们在up中同时储存牛的身高和位置）

    然后就是维护up序列：我们只需要保证i在里面，而且序列时由i生成的（第一个比i大的，第一个比第一个比i大的大的......）。在刚刚的比较过程中，如果有比i小的牛在up尾部，把它pop出来即可（栈）
3) ......一直处理下去......
# 增强版实现
在牛群的末尾加入一个比天还高的牛，这样我们就不需要特殊处理最后一只牛了。比天还高的牛一定被所有前n只牛看见，最后输出ans-n即可


