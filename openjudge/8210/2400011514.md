# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/49257937/)

```
基本信息
#: 49257937
题目: P0200
提交人: 谢冰2400011514(xb谢神)
内存: 10344kB
时间: 190ms
语言: Python3
提交时间: 2025-05-25 09:15:47
```

## 题目理解

我们有一条长度为 `L` 的河流，两端是固定的岩石。在这之间有 `N` 块岩石，每块石头的位置已知。我们可以移除最多 `M` 块中间的石头。

**目标**是：在移除不超过 `M` 块石头后，使得奶牛从起点跳到终点过程中**最短的跳跃距离最大**。

换句话说，我们希望路径中「最短的一跳」尽可能长。这是一个经典的 **最大化最小值** 的问题，适合用 **二分答案法（Binary Search on Answer）** 来做。

---

## 解题思路：二分答案 + 贪心检查

### 步骤 1：排序 & 二分查找

我们对石头位置排序，然后设定一个答案区间 `[low, high]`，分别表示最短跳跃距离的可能范围。初始为 `[1, L]`。

我们在这个范围里二分查找一个最大的 `mid` 值，表示“我们猜测可以让最短跳跃距离至少为 `mid`”。然后用贪心方法去验证：**是否存在一种保留石头的方式，使得所有跳跃距离 ≥ mid，且移除的石头数量 ≤ M？**

### 步骤 2：贪心判断 check(mid)

我们按顺序遍历所有石头，从起点开始，记录上一个保留的石头位置 `last`：

* 如果当前石头 `i` 与 `last` 的距离 `< mid`，就说明这块石头太近了，不满足“每跳 ≥ mid”，所以需要移除。
* 否则，我们保留这个石头，并更新 `last = i`。

最后，统计总共移除了多少块石头。如果 ≤ M，说明当前的 `mid` 是可行的。

---

## 示例解释

输入：

```
L = 25, N = 5, M = 2
stones = [2, 11, 14, 17, 21]
```

排序后：`[0, 2, 11, 14, 17, 21, 25]`，尝试移除最多2个石头，使得所有跳跃距离中最小的尽量大。

最后输出：`4`，即最优策略是移除 `2` 和 `14`，跳跃为 `[0→11→17→21→25]`，跳跃距离为 `[11, 6, 4, 4]`，最小的是 `4`。

---

## Python代码逻辑解释

```python
positions = [0] + stones + [L]
```

加上起点和终点，便于统一处理。

```python
while lo <= hi:
    mid = (lo + hi) // 2
```

经典二分搜索，尝试使跳跃距离至少为 `mid`。

```python
removed = 0
last = 0
for i in range(1, len(positions)):
    if positions[i] - positions[last] < mid:
        removed += 1  # 跳跃太短，要移除这块石头
    else:
        last = i  # 跳跃足够，更新last
```

这个循环用于判断：当前的 `mid` 是否可行。

```python
if removed <= M:
    ans = mid
    lo = mid + 1  # 可以尝试更大
else:
    hi = mid - 1  # 跳跃距离太大了，不可行
```

标准的二分更新逻辑，最终返回答案。

---

## 时间复杂度分析

* 排序：`O(N log N)`
* 每次判断：`O(N)`
* 二分次数：`O(log L)`

所以总复杂度为 `O(N log L)`，在题目范围下表现良好。

