# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/49125774/)

```
基本信息
#: 49125774
题目: P0520
提交人: 谢冰2400011514(xb谢神)
内存: 121360kB
时间: 620ms
语言: Python3
提交时间: 2025-05-12 08:23:10
```

要解决这个问题，我们需要模拟机器翻译软件的工作过程。具体来说，我们需要维护一个内存中的单词列表，并根据访问顺序和内存容量来管理这些单词。每当遇到一个新单词时，如果内存中没有该单词，就需要从外存中查找，并将该单词加入内存。如果内存已满，则需要移除最早进入内存的单词（即遵循先进先出FIFO的原则）。

### 方法思路
1. **初始化内存结构**：使用一个队列来模拟内存中的单词存储，队列的头部是最早进入的单词，尾部是最新进入的单词。
2. **处理每个单词**：对于文章中的每个单词，检查它是否在内存中：
   - **如果存在**：直接跳过，不需要查找词典。
   - **如果不存在**：增加查找次数，并将该单词加入内存。如果内存已满（队列大小等于M），则移除队列头部的单词（最早进入的单词），再将新单词加入队列尾部。

这种方法确保了内存中的单词始终按照访问顺序排列，并且在内存满时按照FIFO原则替换单词。

### 代码解释
1. **输入处理**：读取内存容量M和文章长度N，以及文章中的单词列表。
2. **初始化内存结构**：使用双端队列`deque`来模拟内存，使用集合`memory_set`来快速检查单词是否存在于内存中。
3. **处理每个单词**：遍历单词列表，对于每个单词：
   - **检查内存**：如果单词在`memory_set`中，跳过处理。
   - **内存未命中**：增加查找次数`count`，检查内存是否已满。如果已满，移除队列头部单词并从集合中删除。然后将新单词加入队列尾部并添加到集合中。
4. **输出结果**：打印总的查找次数。

这种方法高效地模拟了FIFO缓存机制，确保在O(N)时间内解决问题，适用于大规模输入。