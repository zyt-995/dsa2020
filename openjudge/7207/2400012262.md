# 状态: [Accepted](http://xzmdsa.openjudge.cn/2025hw2/solution/48545118/)
```
基本信息
#: 48545118
题目: 250202
提交人: 2400012262+周知勤(Tianyi)
内存: 3696kB
时间: 31ms
语言: Python3
提交时间: 2025-03-13 14:16:37
```

# 解题方法说明

这道题最核心的思路就是“奇数阶幻方”的经典构造方法，但这里的矩阵大小是 \\((2N-1) \times (2N-1)\\。其主要步骤概括如下：

1. **初始位置：**  
   将数字 \\(1\\) 放在**第一行**（索引 0）且**中间列**（索引 \\(N-1\\)）的位置。

2. **一般移动：**  
   - 若不越界且下一位置尚未被占用，则将下一数字放在“上一数字的右上方”；
   - 若越界或下一位置已经有数字，则将下一数字放在“上一数字的正下方”。

3. **越界处理：**  
   由于要“右上移”，这里用**取模运算 (mod)** 来自动处理行列的越界情形：
   - 行向上移动 1，当行索引 < 0 时，就变为 `(2N-1) - 1`；
   - 列向右移动 1，当列索引超出 `(2N-1)-1` 时，就变为 0；
   - 也可以直接通过 `(index + 偏移) % (2N - 1)` 的方式让位置“回绕”到矩阵另一侧。

4. **冲突处理：**  
   如果移动到的“右上方”已有数字，则直接往“上一数字”的下方落位（行索引 +1，列索引不变）。通过维护一个temp的行、列变量，避免上一步计算后丢失。

通过上述移动规则，可以依次放置 `(2N-1)^2` 个数字。由于这是经典的奇数阶幻方构建方法，最终会得到行、列、对角线和都相同的幻方。

---

# 解题感想
本题对于边界的处理，如果分别使用条件判断当位于最右侧列或最顶上行单独写填入机制的话，会使得代码较为复杂和冗余(`if-else`判断太多)，但我们如果使用取模运算`(index + offset) % dimension`

# 踩过的坑
注意往右上角移动时，行的索引减少，而列的索引增加。同时还要注意维护当前行、列的位置，因为如果右上角的位置被占据后是移动到当前位置的下一行，而先前计算右上角的位置会使得当前索引丢失。
