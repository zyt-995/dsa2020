## 状态: Accepted

### 基本信息

#:[48362186](http://dsbpython.openjudge.cn/dspythonbook/solution/48362186/)

题目:[P1160](http://dsbpython.openjudge.cn/dspythonbook/P1160/)

语言:[Python3](http://dsbpython.openjudge.cn/dspythonbook/solution/48362186/)

提交人:[2400011491王思杰(24n2400011491)](http://openjudge.cn/user/1415342/in/group-491/)

内存:22636kB

时间:636ms

提交时间:2025-02-26 09:25:45

### 题目分析和解题思路

这道题同时要求遍历所有岛屿且不可重复，从这个角度来讲，就需要一个聪明的穷举算法。

这里我采用动态规划的方式对穷举进行剪枝——其实时一个贪心思路，要想到达第n个岛屿的时间最少，我们要求相同状态下（即之前访问过哪些岛屿？）到达第j个岛屿时的时间最少。这里的相同状态只要访问过的岛屿都相同就算相同，与顺序无关。

总共有n个岛屿，就产生2\*\*n个状态，用一个整数mask来表示这个“状态”，我采用mask的二进制表示来表明哪些岛屿访问过，比如mask = 2\*\*5+2\*\*3+2\*\*0就表示访问过第1，4，6个岛屿。我采用dp\[mask]\[j]表示：在状态mask下，到达第j+1个岛屿需要的最小时间。

在本题中，访问产生的时间差是不对称的，所以一来一回都要考虑到。在递归过程中，我的代码会穷举当前状态mask下，从每一个已经访问的岛屿访问任何一个还没访问的岛屿产生的时间差。这样就解决了不对称的问题。

注意，本题要求一定从第1个岛屿出发，到第n个岛屿结束，所以这两个岛屿一定要特别处理，访问的第一步和最后一步都得特别考虑：

第1个岛屿的处理是简单的，只要在dp的初值中把dp\[1]\[0]=0就行（其余均为float('inf'))，这样只有从第1个岛屿出发的状态对应的时间是有限的。

第n个岛屿不好处理：

首先，第n个岛屿只能最后访问，所以递归过程中mask的取值范围仅限于从1到2\*\*(n-1)-1，通过排除2\*\*(n-1)把第n个岛屿排除掉了。然后，访问最后一个岛屿时必须单独写代码。

我在代码中采用了一些与位运算相关的算符，为方便查看答案的同学，解释如下：

~~~
1 << n #在1的二进制表示中，将所有数字左移n位，实际上就是2**n

mask & (1<<i) #检查mask的第i位是不是1
#&算符生成数字的每一位只有在被作用的两个数字的同一位均是1才为1，否则为0

mask | (1<<j) #把mask的第j位变为1 
#|算符生成数字的每一位只要在被作用的两个数字的同一位有一个是1就为1，否则为0
~~~

P.S.：由于最后一个岛屿只能最后一个到达，所以题给的数据最后一行是用不上的，反之，如果用上了就说明代码出事了

### 我遇到的哪些坑

1、由于递归的过程中不涉及第n个岛屿，所以搜索岛屿时要用range(n-1)，mask的实际范围是range(1,1 << (n-1))

2、第一个和最后一个岛屿得分开处理

3、这道题因为涉及位运算，会产生很多不符合常理的运算，比如，最开始应当令dp\[1]\[0]=0而不是dp\[0]\[0]=0，mask应该从1开始而不是从0开始，都是因为这里采用的是2的0次方而非直接的0

### 旧思路（WA）

这道题我采用了动态规划的思路来减少穷举的计算量，创建了一个二维列表dp。其中dp\[i\]\[j\]表示已经走过i+1个地点（包括起点）且现在在第j点所需的最小用时。

为了储存已有的路径，这个二维列表的每个元素实际上是一个[ t, [] ]的形式，在t 中储存最小用时，在后面那个列表中储存已经走过的地点，用于排除已经走过的地点

目前这个思路写出的代码能够过两个样例，但会输出Wrong Answer