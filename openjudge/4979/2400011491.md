## 状态: Wrong Answer

这道题我采用了动态规划的思路来减少穷举的计算量，创建了一个二维列表dp。其中dp\[i\]\[j\]表示已经走过i+1个地点（包括起点）且现在在第j点所需的最小用时。

为了储存已有的路径，这个二维列表的每个元素实际上是一个[ t, [] ]的形式，在t 中储存最小用时，在后面那个列表中储存已经走过的地点，用于排除已经走过的地点

目前这个思路写出的代码能够过两个样例，但会输出Wrong Answer