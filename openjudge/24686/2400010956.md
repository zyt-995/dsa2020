# 状态: [Accepted](http://xzmdsa.openjudge.cn/2025hw5/solution/49120384/)
```
基本信息
#: 49120384
题目: 6
提交人: 2400010956-彭宇轩
内存: 13020kB
时间: 378ms
语言: Python3
提交时间: 2025-05-11 16:41:00
```

**思路说明**：  
github上已经有了一种解法，但是实现复杂，而且没有注释的话理解十分困难，希望作者可以加一点注释方便理解。
我提供了另一种解法，时间效率稍显逊色，但可读性和实现都更为简单，希望可以帮助同学们解决这个问题。
直接使用搜索进行累加会导致超时。本题中查询操作远少于修改操作，因此不是所有结果都会用到，我们可以等到查询的时候再计算从而实现优化。
本题中某子树的重量同时受到其祖树的操作和子树的操作的影响且影响不同。如果我们使用搜索在储存时就进行所有祖树操作影响的储存，再使用搜索的方法计算子树对查询树的影响，仍然很慢。但是子树查祖树十分方便，因此我们用一个列表记录子树对祖树的影响，再用另一个数组储存各节点的操作。查询时通过向上搜索计算祖树对查询树的影响，再直接读出其子树对它的影响，最终输出计算结果。