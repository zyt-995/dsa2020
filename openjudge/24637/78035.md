```
基本信息
#: 49029442
题目: 8
提交人: 0006178035_谢正茂
内存: 3640kB
时间: 19ms
语言: Python3
提交时间: 2025-04-28 16:09:13
```

### 思路 
按照完全二叉树的特点，每一个结点i，它有两个儿子，分别是2i, 2i+1；有四个孙子，分别是4i,4i+1,4i+2,4i+3。
对于儿子/孙子不在二叉树的情况，在它们的位置上补上0就可以了。

讨论以某结点i为根的子树的最大宝藏，分为两种情况：
1. 包含i：那么就不能包含它的儿子，可以包含它的所有孙子。
2. 不包含i：它的两个儿子的最大宝藏求和。 

两种情况的较大值，就是i根的最大宝藏。
得到的递推公式就是：
```math
l_i = max(l_{2i}+l_{2i+1},node_i+l_{4i}+l_{4i+1}+l_{4i+2}+l_{4i+3})
```

### 坑
i最大为n，对应的孙子最大值为4n+3，所以需要在后面补3n+3个零。在l后面直接补0的办法：
```
    l = [0] + l + [0]*(3*n+3)
```
因为测试数据有问题，可能是len(l)!=n，在OJ上一开始会WA；联系OJ老师已经解决。
在提交的代码中定义一个lambda函数L包装了对l的访问，如果下标大于n，直接返回0。
```
    L = lambda i : l[i] if i<=n else n
```
这样更加稳妥。

### 算法分析
二叉树的结点数目为n，dp算法的时间复杂度为O(n)。
如果采用无缓存的递归算法，复杂度是多少呢？

这里面肯定存在重复计算的问题。
在前面的递推公式中我们发现，计算结点i时需要用到它下面两层结点的值。
从上往下看，第一层(root)的计算次数是1；
第二层的结果只需要被第一层用到，它的计算次数也是1；
第三层的结果被第一层和第二层都用到，它的计算次数是1+1=2；
第j层的计算次数为$`C_j`$，有递推公式：
```math
C_{j}=C_{j-1}+C_{j-2}
```
这不就是著名的斐波那契数列吗？它的复杂度是$`O(k^n)`$的，
其中$`k=\frac{1+\sqrt{5}}{2}`$。

完全二叉树的高度为log(n)，把它代入知道整个算法的复杂度为$`O(n^2)`$，
我们得到了一个有意思的结论。
如果哪位同学采用这种算法，很有可能会超时的。

接下来我们发现2400012128张云涛同学采用了无缓存的递归算法，
用时却和dp算法相差无几，这是怎么回事？

我们发现他在每个树结点i上记录两个数值，分别是包含i的宝藏值$`a_i`$和不包含i的宝藏值$`b_i`$。
于是递推公式是：
```math
a_i, b_i = node_i+b_{2i}+b_{2i+1}, max(a_{2i}, b_{2i})+max(a_{2i+1}, b_{2i+1})
```
也考虑递归算法中重复计算的问题，这时候计算结点i时只需要用到它下面一层结点的值了。
于是每一层结点的实际计算次数是1，也就是说没有重复计算，那么算法的复杂度又变回了O(n)。

Amazing! 看似等效的两个递推公式在算法复杂度方面，有着巨大的差别！



